<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CheckerTree.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checker-core</a> &gt; <a href="index.source.html" class="el_package">com.luchersol.core.specialized_checkers.collection</a> &gt; <span class="el_source">CheckerTree.java</span></div><h1>CheckerTree.java</h1><pre class="source lang-java linenums">package com.luchersol.core.specialized_checkers.collection;

import static com.luchersol.core.util.Message.*;

import java.util.List;
import java.util.Map;

import com.luchersol.core.util.AbstractChecker;
import com.luchersol.core.util.collection.Tree;

/**
 * A specialized checker for {@link Tree} data structures, providing a fluent API to assert various properties
 * and invariants about a tree. This class extends {@link AbstractChecker} and allows for custom or default
 * naming of the checker instance.
 * &lt;p&gt;
 * CheckerTree provides static factory methods for convenient construction from a {@code Tree} instance,
 * a root value, or a root value with a map of children. It supports checks for emptiness, binary structure,
 * symmetry, fullness, depth, number of leaves, and diameter, among others.
 * &lt;/p&gt;
 *
 * &lt;p&gt;Usage Example:&lt;/p&gt;
 * &lt;pre&gt;{@code
 * Tree&lt;Integer&gt; tree = new Tree&lt;&gt;(1);
 * CheckerTree&lt;Integer&gt; checker = CheckerTree.check(tree);
 *      .isBinaryTree()
 *      .minDepth(1);
 * }&lt;/pre&gt;
 *
 * @param &lt;T&gt; the type of elements stored in the tree
 * @see Tree
 * @see AbstractChecker
 */
public class CheckerTree&lt;T&gt; extends AbstractChecker&lt;Tree&lt;T&gt;, CheckerTree&lt;T&gt;&gt; {

    private static final String INIT_TREE = &quot;collections.tree&quot;;
    private static final String DEFAULT_NAME = &quot;Tree&quot;;

    /**
     * Constructs a new {@code CheckerTree} with the specified tree and name.
     *
     * @param tree the underlying tree structure to be wrapped or checked
     * @param name the name associated with this {@code CheckerTree}
     */
    protected CheckerTree(Tree&lt;T&gt; tree, String name) {
<span class="fc" id="L45">        super(tree, name);</span>
<span class="fc" id="L46">    }</span>


    // STATIC CONSTRUCTOR WITH NAME

    /**
     * Creates a CheckerTree for the given tree and assigns a custom name.
     *
     * @param &lt;T&gt; the {@code Tree}'s element type
     * @param tree the tree to check
     * @param name the name to assign to this checker
     * @return a CheckerTree instance for the given tree
     */
    public static &lt;T&gt; CheckerTree&lt;T&gt; check(Tree&lt;T&gt; tree, String name) {
<span class="fc" id="L60">        return new CheckerTree&lt;&gt;(tree, name);</span>
    }

    /**
     * Creates a CheckerTree from a root value and a map of children, and assigns a custom name.
     *
     * @param &lt;T&gt; the {@code Tree}'s element type
     * @param rootValue the value of the root node
     * @param childrenMap a map where each key is a node and the value is a list of its children
     * @param name the name to assign to this checker
     * @return a CheckerTree instance for the constructed tree
     */
    public static &lt;T&gt; CheckerTree&lt;T&gt; check(T rootValue, Map&lt;T, List&lt;T&gt;&gt; childrenMap, String name) {
<span class="fc" id="L73">        Tree&lt;T&gt; tree = new Tree&lt;T&gt;(rootValue, childrenMap);</span>
<span class="fc" id="L74">        return check(tree, name);</span>
    }

    /**
     * Creates a CheckerTree from a root value and assigns a custom name.
     *
     * @param &lt;T&gt; the {@code Tree}'s element type
     * @param rootValue the value of the root node
     * @param name the name to assign to this checker
     * @return a CheckerTree instance for the constructed tree
     */
    public static &lt;T&gt; CheckerTree&lt;T&gt; check(T rootValue, String name) {
<span class="fc" id="L86">        Tree&lt;T&gt; tree = new Tree&lt;T&gt;(rootValue);</span>
<span class="fc" id="L87">        return check(tree, name);</span>
    }

    // STATIC CONSTRUCTOR WITHOUT NAME

    /**
     * Creates a CheckerTree for the given tree with a default name.
     *
     * @param &lt;T&gt;  the {@code Tree}'s element type
     * @param tree the tree to check
     * @return a CheckerTree instance for the given tree
     */
    public static &lt;T&gt; CheckerTree&lt;T&gt; check(Tree&lt;T&gt; tree) {
<span class="fc" id="L100">        return check(tree, DEFAULT_NAME);</span>
    }

    /**
     * Creates a CheckerTree from a root value and a map of children, with a default name.
     *
     * @param &lt;T&gt;  the {@code Tree}'s element type
     * @param rootValue the value of the root node
     * @param childrenMap a map where each key is a node and the value is a list of its children
     * @return a CheckerTree instance for the constructed tree
     */
    public static &lt;T&gt; CheckerTree&lt;T&gt; check(T rootValue, Map&lt;T, List&lt;T&gt;&gt; childrenMap) {
<span class="fc" id="L112">        Tree&lt;T&gt; tree = new Tree&lt;T&gt;(rootValue, childrenMap);</span>
<span class="fc" id="L113">        return check(tree);</span>
    }

    /**
     * Creates a CheckerTree from a root value with a default name.
     *
     * @param &lt;T&gt;  the {@code Tree}'s element type
     * @param rootValue the value of the root node
     * @return a CheckerTree instance for the constructed tree
     */
    public static &lt;T&gt; CheckerTree&lt;T&gt; check(T rootValue) {
<span class="fc" id="L124">        Tree&lt;T&gt; tree = new Tree&lt;T&gt;(rootValue);</span>
<span class="fc" id="L125">        return check(tree);</span>
    }

    /**
     * Returns this instance (for fluent API).
     *
     * @return this CheckerTree instance
     */
    @Override
    protected CheckerTree&lt;T&gt; self() {
<span class="fc" id="L135">        return this;</span>
    }

    /**
     * Checks if the tree is empty.
     *
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; isEmpty() {
<span class="fc" id="L144">        return is(tree -&gt; tree.isEmpty(), sendMessage(INIT_TREE, &quot;is_empty&quot;));</span>
    }

    /**
     * Checks if the tree is a binary tree (each node has at most two children).
     *
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; isBinaryTree() {
<span class="fc" id="L153">        return is(tree -&gt; tree.isBinaryTree(), sendMessage(INIT_TREE, &quot;is_binary_tree&quot;));</span>
    }

    /**
     * Checks if the tree is symmetric (mirror image around its center).
     *
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; isSymmetric() {
<span class="fc" id="L162">        return is(tree -&gt; tree.isSymmetric(), sendMessage(INIT_TREE, &quot;is_symmetric&quot;));</span>
    }

    /**
     * Checks if the tree is full (every node has 0 or 2 children).
     *
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; isFull() {
<span class="fc" id="L171">        return is(tree -&gt; tree.isFull(), sendMessage(INIT_TREE, &quot;is_full&quot;));</span>
    }

    /**
     * Checks if the tree's depth is at least the specified minimum.
     *
     * @param min the minimum depth
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; minDepth(int min) {
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">        return is(tree -&gt; min &lt;= tree.getDepth(), sendMessage(INIT_TREE, &quot;min_depth&quot;, this.object.getDepth(), min));</span>
    }

    /**
     * Checks if the tree's depth is at most the specified maximum.
     *
     * @param max the maximum depth
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; maxDepth(int max) {
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">        return is(tree -&gt; tree.getDepth() &lt;= max,</span>
<span class="fc" id="L192">            sendMessage(INIT_TREE, &quot;max_depth&quot;, this.object.getDepth(), max));</span>
    }

    /**
     * Checks if the tree's depth is within the specified range (inclusive).
     *
     * @param min the minimum depth
     * @param max the maximum depth
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; inRangeDepth(int min, int max) {
<span class="pc bpc" id="L203" title="2 of 4 branches missed.">        return is(tree -&gt; min &lt;= tree.getDepth() &amp;&amp; tree.getDepth() &lt;= max,</span>
<span class="fc" id="L204">            sendMessage(INIT_TREE, &quot;in_range_depth&quot;, this.object.getDepth(), min, max));</span>
    }

    /**
     * Checks if the number of leaves in the tree is at least the specified minimum.
     *
     * @param min the minimum number of leaves
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; minLeaves(int min) {
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        return is(tree -&gt; min &lt;= tree.countLeaves(),</span>
<span class="fc" id="L215">            sendMessage(INIT_TREE, &quot;min_leaves&quot;, this.object.countLeaves(), min));</span>
    }

    /**
     * Checks if the number of leaves in the tree is at most the specified maximum.
     *
     * @param max the maximum number of leaves
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; maxLeaves(int max) {
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        return is(tree -&gt; tree.countLeaves() &lt;= max,</span>
<span class="fc" id="L226">            sendMessage(INIT_TREE, &quot;max_leaves&quot;, this.object.countLeaves(), max));</span>
    }

    /**
     * Checks if the number of leaves in the tree is within the specified range (inclusive).
     *
     * @param min the minimum number of leaves
     * @param max the maximum number of leaves
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; inRangeLeaves(int min, int max) {
<span class="pc bpc" id="L237" title="2 of 4 branches missed.">        return is(tree -&gt; min &lt;= tree.countLeaves() &amp;&amp; tree.countLeaves() &lt;= max,</span>
<span class="fc" id="L238">            sendMessage(INIT_TREE, &quot;in_range_leaves&quot;, this.object.countLeaves(), min, max));</span>
    }

    /**
     * Checks if the tree's diameter is at least the specified minimum.
     *
     * @param min the minimum diameter
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; minDiamenter(int min) {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">        return is(tree -&gt; min &lt;= tree.diameter(),</span>
<span class="fc" id="L249">            sendMessage(INIT_TREE, &quot;min_diamenter&quot;, this.object.diameter(), min));</span>
    }

    /**
     * Checks if the tree's diameter is at most the specified maximum.
     *
     * @param max the maximum diameter
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; maxDiamenter(int max) {
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        return is(tree -&gt; tree.diameter() &lt;= max,</span>
<span class="fc" id="L260">            sendMessage(INIT_TREE, &quot;max_diamenter&quot;, this.object.diameter(), max));</span>
    }

    /**
     * Checks if the tree's diameter is within the specified range (inclusive).
     *
     * @param min the minimum diameter
     * @param max the maximum diameter
     * @return this CheckerTree instance
     */
    public CheckerTree&lt;T&gt; inRangeDiamenter(int min, int max) {
<span class="pc bpc" id="L271" title="2 of 4 branches missed.">        return is(tree -&gt; min &lt;= tree.diameter() &amp;&amp; tree.diameter() &lt;= max,</span>
<span class="fc" id="L272">            sendMessage(INIT_TREE, &quot;in_range_diamenter&quot;, this.object.diameter(), min, max));</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>