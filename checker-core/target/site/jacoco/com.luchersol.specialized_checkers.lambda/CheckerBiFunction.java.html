<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CheckerBiFunction.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">checker-core</a> &gt; <a href="index.source.html" class="el_package">com.luchersol.core.specialized_checkers.lambda</a> &gt; <span class="el_source">CheckerBiFunction.java</span></div><h1>CheckerBiFunction.java</h1><pre class="source lang-java linenums">package com.luchersol.core.specialized_checkers.lambda;

import static com.luchersol.core.util.Message.*;

import java.util.function.BiFunction;

import com.luchersol.core.util.AbstractChecker;
import com.luchersol.core.util.Cloner;
import com.luchersol.core.util.Utils;


/**
 * A specialized checker for {@link BiFunction} instances, providing a fluent API for validating
 * the behavior of a {@code BiFunction&lt;T, U, R&gt;}. This class allows you to assert that a given
 * {@code BiFunction} can be applied without throwing exceptions, produces expected results,
 * or returns non-null values for specific inputs. It also supports optional deep cloning of
 * input arguments before passing them to the function, to ensure immutability or test side effects.
 * &lt;p&gt;
 * Example usage:
 * &lt;pre&gt;
 *     CheckerBiFunction&amp;lt;String, Integer, String&amp;gt; checker =
 *         CheckerBiFunction.check((s, i) -&gt; s.repeat(i))
 *             .activateDeepClone()
 *             .applyWithoutException(&quot;abc&quot;, 2)
 *             .producesExpected(&quot;abc&quot;, 2, &quot;abcabc&quot;)
 *             .producesNonNull(&quot;abc&quot;, 2);
 * &lt;/pre&gt;
 *
 * @param &lt;T&gt; the type of the first argument to the function
 * @param &lt;U&gt; the type of the second argument to the function
 * @param &lt;R&gt; the type of the result of the function
 *
 * @see BiFunction
 * @see AbstractChecker
 */
public class CheckerBiFunction&lt;T, U, R&gt; extends AbstractChecker&lt;BiFunction&lt;T, U, R&gt;, CheckerBiFunction&lt;T, U, R&gt;&gt; {

    private static final String INIT_BI_FUNCTION = &quot;lambda.bifunction&quot;;
    private static final String DEFAULT_NAME = &quot;Function&quot;;

    private boolean deepClone;

    /**
     * Constructs a new {@code CheckerBiFunction} with the specified {@link BiFunction} and name.
     *
     * @param function the {@link BiFunction} to be wrapped and checked
     * @param name the name identifying this checker function
     */
    protected CheckerBiFunction(BiFunction&lt;T, U, R&gt; function, String name) {
<span class="fc" id="L50">        super(function, name);</span>
<span class="fc" id="L51">    }</span>

    /**
     * Creates a CheckerBiFunction for the given BiFunction and assigns a custom name.
     *
     * @param &lt;T&gt;      the type of the first input to the {@code BiFunction} being checked
     * @param &lt;U&gt;      the type of the second input to the {@code BiFunction} being checked
     * @param &lt;R&gt;      the type of the result returned by the {@code BiFunction}
     * @param bifunction the BiFunction to check
     * @param name the name to assign to this checker
     * @return a CheckerBiFunction instance for the given BiFunction
     */
    public static &lt;T,U,R&gt; CheckerBiFunction&lt;T, U, R&gt; check(BiFunction&lt;T, U, R&gt; bifunction, String name) {
<span class="fc" id="L64">        return new CheckerBiFunction&lt;&gt;(bifunction, name);</span>
    }

    /**
     * Creates a CheckerBiFunction for the given BiFunction with a default name.
     *
     * @param &lt;T&gt;      the type of the first input to the {@code BiFunction} being checked
     * @param &lt;U&gt;      the type of the second input to the {@code BiFunction} being checked
     * @param &lt;R&gt;      the type of the result returned by the {@code BiFunction}
     * @param bifunction the BiFunction to check
     * @return a CheckerBiFunction instance for the given BiFunction
     */
    public static &lt;T,U,R&gt; CheckerBiFunction&lt;T, U, R&gt; check(BiFunction&lt;T, U, R&gt; bifunction) {
<span class="fc" id="L77">        return check(bifunction, DEFAULT_NAME);</span>
    }

    /**
     * Returns this instance (for fluent API).
     *
     * @return this CheckerBiFunction instance
     */
    @Override
    protected CheckerBiFunction&lt;T, U, R&gt; self() {
<span class="fc" id="L87">        return this;</span>
    }

    /**
     * Activates deep cloning of inputs before passing them to the BiFunction.
     *
     * @return this CheckerBiFunction instance
     */
    public CheckerBiFunction&lt;T, U, R&gt; activateDeepClone() {
<span class="fc" id="L96">        this.deepClone = true;</span>
<span class="fc" id="L97">        return self();</span>
    }

    /**
     * Deactivates deep cloning of inputs before passing them to the BiFunction.
     *
     * @return this CheckerBiFunction instance
     */
    public CheckerBiFunction&lt;T, U, R&gt; deactivateDeepClone() {
<span class="fc" id="L106">        this.deepClone = false;</span>
<span class="fc" id="L107">        return self();</span>
    }

    /**
     * Returns the first input, deep cloned if deepClone is enabled.
     *
     * @param input the first input value
     * @return the (possibly cloned) first input
     */
    private T getInput1(T input) {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        return this.deepClone ? Cloner.deepClone(input) : input;</span>
    }

    /**
     * Returns the second input, deep cloned if deepClone is enabled.
     *
     * @param input the second input value
     * @return the (possibly cloned) second input
     */
    private U getInput2(U input) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        return this.deepClone ? Cloner.deepClone(input) : input;</span>
    }

    /**
     * Checks that the BiFunction can be applied to the given inputs without throwing an exception.
     *
     * @param input1 the first input value
     * @param input2 the second input value
     * @return this CheckerBiFunction instance
     */
    public CheckerBiFunction&lt;T, U, R&gt; applyWithoutException(T input1, U input2) {
<span class="fc" id="L138">        return is(f -&gt; {</span>
            try {
<span class="fc" id="L140">                T processInput1 = getInput1(input1);</span>
<span class="fc" id="L141">                U processInput2 = getInput2(input2);</span>
<span class="fc" id="L142">                f.apply(processInput1, processInput2);</span>
<span class="fc" id="L143">                return true;</span>
<span class="fc" id="L144">            } catch (Exception e) {</span>
<span class="fc" id="L145">                return false;</span>
            }
<span class="fc" id="L147">        }, sendMessage(INIT_BI_FUNCTION, &quot;apply_without_exception&quot;, input1, input2));</span>
    }

    /**
     * Checks that the BiFunction produces the expected result for the given inputs.
     *
     * @param input1 the first input value
     * @param input2 the second input value
     * @param expected the expected result
     * @return this CheckerBiFunction instance
     */
    public CheckerBiFunction&lt;T, U, R&gt; producesExpected(T input1, U input2, R expected) {
<span class="fc" id="L159">        return is(f -&gt; {</span>
            try {
<span class="fc" id="L161">                T processInput1 = getInput1(input1);</span>
<span class="fc" id="L162">                U processInput2 = getInput2(input2);</span>
<span class="fc" id="L163">                R result = f.apply(processInput1, processInput2);</span>
<span class="fc" id="L164">                return Utils.equalsContent(expected, result);</span>
<span class="nc" id="L165">            } catch (Exception e) {</span>
<span class="nc" id="L166">                return false;</span>
            }
<span class="fc" id="L168">        }, sendMessage(INIT_BI_FUNCTION, &quot;produces_expected&quot;, input1, input2, expected));</span>
    }

    /**
     * Checks that the BiFunction produces a non-null result for the given inputs.
     *
     * @param input1 the first input value
     * @param input2 the second input value
     * @return this CheckerBiFunction instance
     */
    public CheckerBiFunction&lt;T, U, R&gt; producesNonNull(T input1, U input2) {
<span class="fc" id="L179">        return is(f -&gt; {</span>
            try {
<span class="fc" id="L181">                T processInput1 = getInput1(input1);</span>
<span class="fc" id="L182">                U processInput2 = getInput2(input2);</span>
<span class="fc bfc" id="L183" title="All 2 branches covered.">                return f.apply(processInput1, processInput2) != null;</span>
<span class="nc" id="L184">            } catch (Exception e) {</span>
<span class="nc" id="L185">                return false;</span>
            }
<span class="fc" id="L187">        }, sendMessage(INIT_BI_FUNCTION, &quot;produces_non_null&quot;, input1, input2));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>